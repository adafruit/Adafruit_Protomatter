<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adafruit Protomatter: core.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adafruit Protomatter
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">core.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
</div>
<p><a href="core_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___p_m__pin.html">_PM_pin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_protomatter__core.html">Protomatter_core</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af659eb7a92f2ae47fac607db2eca4bc5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8h.html#af659eb7a92f2ae47fac607db2eca4bc5">ProtomatterStatus</a> { <b>PROTOMATTER_OK</b>, 
<b>PROTOMATTER_ERR_PINS</b>, 
<b>PROTOMATTER_ERR_MALLOC</b>, 
<b>PROTOMATTER_ERR_ARG</b>
 }</td></tr>
<tr class="separator:af659eb7a92f2ae47fac607db2eca4bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2382fb4f3e05345517f48ccfe8327da6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_8h.html#af659eb7a92f2ae47fac607db2eca4bc5">ProtomatterStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8h.html#a2382fb4f3e05345517f48ccfe8327da6">_PM_init</a> (<a class="el" href="struct_protomatter__core.html">Protomatter_core</a> *core, uint16_t bitWidth, uint8_t bitDepth, uint8_t rgbCount, uint8_t *rgbList, uint8_t addrCount, uint8_t *addrList, uint8_t clockPin, uint8_t latchPin, uint8_t oePin, bool doubleBuffer, void *timer)</td></tr>
<tr class="memdesc:a2382fb4f3e05345517f48ccfe8327da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize values in <a class="el" href="struct_protomatter__core.html">Protomatter_core</a> structure.  <a href="#a2382fb4f3e05345517f48ccfe8327da6">More...</a><br /></td></tr>
<tr class="separator:a2382fb4f3e05345517f48ccfe8327da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb36fc4f875be610434118739356fb5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_8h.html#af659eb7a92f2ae47fac607db2eca4bc5">ProtomatterStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8h.html#abb36fc4f875be610434118739356fb5c">_PM_begin</a> (<a class="el" href="struct_protomatter__core.html">Protomatter_core</a> *core)</td></tr>
<tr class="memdesc:abb36fc4f875be610434118739356fb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate display buffers and populate additional elements of a Protomatter matrix.  <a href="#abb36fc4f875be610434118739356fb5c">More...</a><br /></td></tr>
<tr class="separator:abb36fc4f875be610434118739356fb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d7c90c3c5b83a38da3fd522f68abd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8h.html#a98d7c90c3c5b83a38da3fd522f68abd7">_PM_stop</a> (<a class="el" href="struct_protomatter__core.html">Protomatter_core</a> *core)</td></tr>
<tr class="memdesc:a98d7c90c3c5b83a38da3fd522f68abd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable (but do not deallocate) a Protomatter matrix. Disables matrix by setting OE pin HIGH and writing all-zero data to matrix shift registers, so it won't halt with lit LEDs.  <a href="#a98d7c90c3c5b83a38da3fd522f68abd7">More...</a><br /></td></tr>
<tr class="separator:a98d7c90c3c5b83a38da3fd522f68abd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9b720e159e7ac6863915ee7e889768"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8h.html#ace9b720e159e7ac6863915ee7e889768">_PM_resume</a> (<a class="el" href="struct_protomatter__core.html">Protomatter_core</a> *core)</td></tr>
<tr class="memdesc:ace9b720e159e7ac6863915ee7e889768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start or restart a matrix. Initialize counters, configure and start timer.  <a href="#ace9b720e159e7ac6863915ee7e889768">More...</a><br /></td></tr>
<tr class="separator:ace9b720e159e7ac6863915ee7e889768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf89afcb7761b40e2cfa65a70bce5675"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8h.html#adf89afcb7761b40e2cfa65a70bce5675">_PM_free</a> (<a class="el" href="struct_protomatter__core.html">Protomatter_core</a> *core)</td></tr>
<tr class="memdesc:adf89afcb7761b40e2cfa65a70bce5675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate memory associated with <a class="el" href="struct_protomatter__core.html">Protomatter_core</a> structure (e.g. screen data, pin lists for data and rows). Does not deallocate the structure itself.  <a href="#adf89afcb7761b40e2cfa65a70bce5675">More...</a><br /></td></tr>
<tr class="separator:adf89afcb7761b40e2cfa65a70bce5675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb462880fa61b8dcc1bee712a9be2f58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8h.html#abb462880fa61b8dcc1bee712a9be2f58">_PM_row_handler</a> (<a class="el" href="struct_protomatter__core.html">Protomatter_core</a> *core)</td></tr>
<tr class="memdesc:abb462880fa61b8dcc1bee712a9be2f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix "row handler" that's called by the timer interrupt. Handles row address lines and issuing data to matrix.  <a href="#abb462880fa61b8dcc1bee712a9be2f58">More...</a><br /></td></tr>
<tr class="separator:abb462880fa61b8dcc1bee712a9be2f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d7939d31d18e0763fcdf47ad5b298c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8h.html#a00d7939d31d18e0763fcdf47ad5b298c">_PM_getFrameCount</a> (<a class="el" href="struct_protomatter__core.html">Protomatter_core</a> *core)</td></tr>
<tr class="memdesc:a00d7939d31d18e0763fcdf47ad5b298c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current value of frame counter and resets its value to zero. Two calls to this, timed one second apart (or use math with other intervals), can be used to get a rough frames-per-second value for the matrix (since this is difficult to estimate beforehand).  <a href="#a00d7939d31d18e0763fcdf47ad5b298c">More...</a><br /></td></tr>
<tr class="separator:a00d7939d31d18e0763fcdf47ad5b298c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479b3bbe256525ac43cc1e835d70b532"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8h.html#a479b3bbe256525ac43cc1e835d70b532">_PM_timerStart</a> (void *tptr, uint32_t period)</td></tr>
<tr class="memdesc:a479b3bbe256525ac43cc1e835d70b532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start (or restart) a timer/counter peripheral.  <a href="#a479b3bbe256525ac43cc1e835d70b532">More...</a><br /></td></tr>
<tr class="separator:a479b3bbe256525ac43cc1e835d70b532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf68ecae1fb8101d8cc73d67eea533a0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8h.html#acf68ecae1fb8101d8cc73d67eea533a0">_PM_timerStop</a> (void *tptr)</td></tr>
<tr class="memdesc:acf68ecae1fb8101d8cc73d67eea533a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop timer/counter peripheral.  <a href="#acf68ecae1fb8101d8cc73d67eea533a0">More...</a><br /></td></tr>
<tr class="separator:acf68ecae1fb8101d8cc73d67eea533a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887e8b5eb089e72b544b296a134f6d7c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8h.html#a887e8b5eb089e72b544b296a134f6d7c">_PM_timerGetCount</a> (void *tptr)</td></tr>
<tr class="memdesc:a887e8b5eb089e72b544b296a134f6d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a timer/counter peripheral's current count.  <a href="#a887e8b5eb089e72b544b296a134f6d7c">More...</a><br /></td></tr>
<tr class="separator:a887e8b5eb089e72b544b296a134f6d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e9ef50719d587b0b0a6c8157320c95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8h.html#a71e9ef50719d587b0b0a6c8157320c95">_PM_convert_565</a> (<a class="el" href="struct_protomatter__core.html">Protomatter_core</a> *core, uint16_t *source, uint16_t width)</td></tr>
<tr class="memdesc:a71e9ef50719d587b0b0a6c8157320c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts image data from GFX16 canvas to the matrices weird internal format.  <a href="#a71e9ef50719d587b0b0a6c8157320c95">More...</a><br /></td></tr>
<tr class="separator:a71e9ef50719d587b0b0a6c8157320c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6eb479b93756b3d6585b1a835955d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8h.html#afa6eb479b93756b3d6585b1a835955d7">_PM_swapbuffer_maybe</a> (<a class="el" href="struct_protomatter__core.html">Protomatter_core</a> *core)</td></tr>
<tr class="memdesc:afa6eb479b93756b3d6585b1a835955d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pauses until the next vertical blank to avoid 'tearing' animation (if display is double-buffered). If single-buffered, has no effect.  <a href="#afa6eb479b93756b3d6585b1a835955d7">More...</a><br /></td></tr>
<tr class="separator:afa6eb479b93756b3d6585b1a835955d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Part of Adafruit's Protomatter library for HUB75-style RGB LED matrices.</p>
<p>Adafruit invests time and resources providing this open source code, please support Adafruit and open-source hardware by purchasing products from Adafruit!</p>
<p>Written by Phil "Paint Your Dragon" Burgess and Jeff Epler for Adafruit Industries, with contributions from the open source community.</p>
<p>BSD license, all text here must be included in any redistribution. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="af659eb7a92f2ae47fac607db2eca4bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af659eb7a92f2ae47fac607db2eca4bc5">&#9670;&nbsp;</a></span>ProtomatterStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="core_8h.html#af659eb7a92f2ae47fac607db2eca4bc5">ProtomatterStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Status type returned by some functions. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2382fb4f3e05345517f48ccfe8327da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2382fb4f3e05345517f48ccfe8327da6">&#9670;&nbsp;</a></span>_PM_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_8h.html#af659eb7a92f2ae47fac607db2eca4bc5">ProtomatterStatus</a> _PM_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_protomatter__core.html">Protomatter_core</a> *&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bitWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rgbCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rgbList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addrCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>addrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>clockPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>latchPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>oePin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doubleBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>timer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize values in <a class="el" href="struct_protomatter__core.html">Protomatter_core</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core</td><td>Pointer to <a class="el" href="struct_protomatter__core.html">Protomatter_core</a> structure. </td></tr>
    <tr><td class="paramname">bitWidth</td><td>Total width of RGB matrix chain, in pixels. Usu. some multiple of 32, but maybe exceptions. </td></tr>
    <tr><td class="paramname">bitDepth</td><td>Color "depth" in bitplanes, determines range of shades of red, green and blue. e.g. passing 4 bits = 16 shades ea. R,G,B = 16x16x16 = 4096 colors. </td></tr>
    <tr><td class="paramname">rgbCount</td><td>Number of "sets" of RGB data pins, each set containing 6 pins (2 ea. R,G,B). Typically 1, indicating a single matrix (or matrix chain). In theory (but not yet extensively tested), multiple sets of pins can be driven in parallel, up to 5 on some devices (if the hardware design provides all those bits on one PORT). </td></tr>
    <tr><td class="paramname">rgbList</td><td>A uint8_t array of pins (values are platform- dependent), 6X the prior rgbCount value, corresponding to the 6 output color bits for a matrix (or chain). Order is upper-half red, green, blue, lower-half red, green blue (repeat for each add'l chain). All the RGB pins (plus the clock pin below on some architectures) MUST be on the same PORT register. It's recommended (but not required) that all RGB pins (and clock depending on arch) be within the same byte of a PORT (but do not need to be sequential or contiguous within that byte) for more efficient RAM utilization. For two concurrent chains, same principle but 16-bit word. </td></tr>
    <tr><td class="paramname">addrCount</td><td>Number of row address lines required of matrix. Total pixel height is then 2 x 2^addrCount, e.g. 32-pixel-tall matrices have 4 row address lines. </td></tr>
    <tr><td class="paramname">addrList</td><td>A uint8_t array of pins (platform-dependent pin numbering), one per row address line. </td></tr>
    <tr><td class="paramname">clockPin</td><td>RGB clock pin (platform-dependent pin #). </td></tr>
    <tr><td class="paramname">latchPin</td><td>RGB data latch pin (platform-dependent pin #). </td></tr>
    <tr><td class="paramname">oePin</td><td>Output enable pin (platform-dependent pin #), active low. </td></tr>
    <tr><td class="paramname">doubleBuffer</td><td>If true, two matrix buffers are allocated, so changing display contents doesn't introduce artifacts mid-conversion. Requires ~2X RAM. </td></tr>
    <tr><td class="paramname">timer</td><td>Pointer to timer peripheral or timer-related struct (architecture-dependent), or NULL to use a default timer ID (also arch-dependent). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ProtomatterStatus status, one of: PROTOMATTER_OK if everything is good. PROTOMATTER_ERR_PINS if data and/or clock pins are split across different PORTs. PROTOMATTER_ERR_MALLOC if insufficient RAM to allocate display memory. PROTOMATTER_ERR_ARG if a bad value (core or timer pointer) was passed in. </dd></dl>

</div>
</div>
<a id="abb36fc4f875be610434118739356fb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb36fc4f875be610434118739356fb5c">&#9670;&nbsp;</a></span>_PM_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_8h.html#af659eb7a92f2ae47fac607db2eca4bc5">ProtomatterStatus</a> _PM_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_protomatter__core.html">Protomatter_core</a> *&#160;</td>
          <td class="paramname"><em>core</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate display buffers and populate additional elements of a Protomatter matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core</td><td>Pointer to <a class="el" href="struct_protomatter__core.html">Protomatter_core</a> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ProtomatterStatus status, one of: PROTOMATTER_OK if everything is good. PROTOMATTER_ERR_PINS if data and/or clock pins are split across different PORTs. PROTOMATTER_ERR_MALLOC if insufficient RAM to allocate display memory. PROTOMATTER_ERR_ARG if a bad value. </dd></dl>

</div>
</div>
<a id="a98d7c90c3c5b83a38da3fd522f68abd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d7c90c3c5b83a38da3fd522f68abd7">&#9670;&nbsp;</a></span>_PM_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _PM_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_protomatter__core.html">Protomatter_core</a> *&#160;</td>
          <td class="paramname"><em>core</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable (but do not deallocate) a Protomatter matrix. Disables matrix by setting OE pin HIGH and writing all-zero data to matrix shift registers, so it won't halt with lit LEDs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core</td><td>Pointer to <a class="el" href="struct_protomatter__core.html">Protomatter_core</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace9b720e159e7ac6863915ee7e889768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9b720e159e7ac6863915ee7e889768">&#9670;&nbsp;</a></span>_PM_resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _PM_resume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_protomatter__core.html">Protomatter_core</a> *&#160;</td>
          <td class="paramname"><em>core</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start or restart a matrix. Initialize counters, configure and start timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core</td><td>Pointer to <a class="el" href="struct_protomatter__core.html">Protomatter_core</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf89afcb7761b40e2cfa65a70bce5675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf89afcb7761b40e2cfa65a70bce5675">&#9670;&nbsp;</a></span>_PM_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _PM_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_protomatter__core.html">Protomatter_core</a> *&#160;</td>
          <td class="paramname"><em>core</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate memory associated with <a class="el" href="struct_protomatter__core.html">Protomatter_core</a> structure (e.g. screen data, pin lists for data and rows). Does not deallocate the structure itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core</td><td>Pointer to <a class="el" href="struct_protomatter__core.html">Protomatter_core</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb462880fa61b8dcc1bee712a9be2f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb462880fa61b8dcc1bee712a9be2f58">&#9670;&nbsp;</a></span>_PM_row_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _PM_row_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_protomatter__core.html">Protomatter_core</a> *&#160;</td>
          <td class="paramname"><em>core</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix "row handler" that's called by the timer interrupt. Handles row address lines and issuing data to matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core</td><td>Pointer to <a class="el" href="struct_protomatter__core.html">Protomatter_core</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00d7939d31d18e0763fcdf47ad5b298c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d7939d31d18e0763fcdf47ad5b298c">&#9670;&nbsp;</a></span>_PM_getFrameCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t _PM_getFrameCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_protomatter__core.html">Protomatter_core</a> *&#160;</td>
          <td class="paramname"><em>core</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current value of frame counter and resets its value to zero. Two calls to this, timed one second apart (or use math with other intervals), can be used to get a rough frames-per-second value for the matrix (since this is difficult to estimate beforehand). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core</td><td>Pointer to <a class="el" href="struct_protomatter__core.html">Protomatter_core</a> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Frame count since previous call to function, as a uint32_t. </dd></dl>

</div>
</div>
<a id="a479b3bbe256525ac43cc1e835d70b532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479b3bbe256525ac43cc1e835d70b532">&#9670;&nbsp;</a></span>_PM_timerStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _PM_timerStart </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start (or restart) a timer/counter peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tptr</td><td>Pointer to timer/counter peripheral OR a struct encapsulating information about a timer/counter periph (architecture-dependent). </td></tr>
    <tr><td class="paramname">period</td><td>Timer 'top' / rollover value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf68ecae1fb8101d8cc73d67eea533a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf68ecae1fb8101d8cc73d67eea533a0">&#9670;&nbsp;</a></span>_PM_timerStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t _PM_timerStop </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop timer/counter peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tptr</td><td>Pointer to timer/counter peripheral OR a struct encapsulating information about a timer/counter periph (architecture-dependent). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Counter value when timer was stopped. </dd></dl>

</div>
</div>
<a id="a887e8b5eb089e72b544b296a134f6d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887e8b5eb089e72b544b296a134f6d7c">&#9670;&nbsp;</a></span>_PM_timerGetCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t _PM_timerGetCount </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query a timer/counter peripheral's current count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tptr</td><td>Pointer to timer/counter peripheral OR a struct encapsulating information about a timer/counter periph (architecture-dependent). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Counter value. </dd></dl>

</div>
</div>
<a id="a71e9ef50719d587b0b0a6c8157320c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e9ef50719d587b0b0a6c8157320c95">&#9670;&nbsp;</a></span>_PM_convert_565()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _PM_convert_565 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_protomatter__core.html">Protomatter_core</a> *&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts image data from GFX16 canvas to the matrices weird internal format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core</td><td>Pointer to <a class="el" href="struct_protomatter__core.html">Protomatter_core</a> structure. </td></tr>
    <tr><td class="paramname">source</td><td>Pointer to source image data (see Adafruit_GFX 16-bit canvas type for format). </td></tr>
    <tr><td class="paramname">width</td><td>Width of canvas in pixels, as this may be different than the matrix pixel width due to row padding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa6eb479b93756b3d6585b1a835955d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6eb479b93756b3d6585b1a835955d7">&#9670;&nbsp;</a></span>_PM_swapbuffer_maybe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _PM_swapbuffer_maybe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_protomatter__core.html">Protomatter_core</a> *&#160;</td>
          <td class="paramname"><em>core</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pauses until the next vertical blank to avoid 'tearing' animation (if display is double-buffered). If single-buffered, has no effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core</td><td>Pointer to <a class="el" href="struct_protomatter__core.html">Protomatter_core</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
